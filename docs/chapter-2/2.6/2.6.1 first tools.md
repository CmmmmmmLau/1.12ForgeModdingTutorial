工具的添加过程和添加物品时一样, 但可惜的是过程无法简化. 如果你想要添加特定类型的工具那么就必定要新建一个类. 唯一多了的一个步骤是首先得要给工具添加一种材料类别, 因为写的都是铜, 所以就添加铜工具进去. 

## 注册类

首先为了分类,需要新建一个`Tool`包, 在包内新建一个`ToolRegistryHandler` 类. 随后添加材料.

```java
public static final Item.ToolMaterial Copper = EnumHelper.addToolMaterial(
Testmod.MOD_ID + ":" + "Copper", 2, 200, 5.0F, 3.0F, 14);
```
有了`Forge` 的帮助, 工具材料的添加变得非常简单.  只需要使用 `EnumHelper` 类中的构造方法即可便捷的添加. 其中传入的六个参数作用分别是:
- name: 材料种类的名字, 但在这里似乎没有必须要小写的限制
- harvestLevel: 挖掘等级
- maxUses: 耐久值
- efficiency: 挖掘速度
- damage: 造成的伤害, 实际攻击面板 = 不同工具的系数 * 数值
- enchantability: 附魔能力. 数字越高在附魔的时候越有概率获得高级附魔词条

因为材料是铜, 因此挖掘等级和铁一致, 但是比铁的耐久度`(250)`和挖掘速度`(6.0F)`略慢. 其他则保持一致.
剩下部分就是和物品一样的代码了.
```java
@Mod.EventBusSubscriber  
public class ItemRegistryHandler {  
  
    public static final Item.ToolMaterial Copper = EnumHelper.addToolMaterial(Testmod.MOD_ID + ":" + "Copper", 2, 200, 5.0F, 3.0F, 14);
  
    @SubscribeEvent  
    public static void onRegistry(RegistryEvent.Register<Item> event) {  
        IForgeRegistry<Item> registry = event.getRegistry();  
  
        registry.registerAll(  
                  
        );  
    }  
    @SubscribeEvent  
    @SideOnly(Side.CLIENT)  
    public static void onModelRegistry(ModelRegistryEvent event) {  
			
    }
}
```

## 斧模板
毫无区别的代码, 就是参数列表多加了材料, 修改一下要继承的超类.
```java
public class ToolPickAxe extends ItemPickaxe {  
    private String name;  
  
    ToolPickAxe(ToolMaterial material, String name){  
        super(material);  
        setRegistryName(name);  
        setTranslationKey(Testmod.MOD_ID + "." + name);  
        setCreativeTab(ItemMod.TEST_MOD_TAB);  
  
        this.name = name;  
    }
}
```
对于其他种类的工具, 只需要继承对应的类即可. 
分别是: 
- 剑`ItemSword`
- 斧`ItemAxe`
- 锄`ItemHoe`
- 镐`ItemPickaxe`
- 锹`ItemSpade`

## 模型Json
```js
{  
  "parent": "item/handheld",  
  "textures": {  
    "layer0": "testmod:item/copper_pickaxe"  
  }  
}

```