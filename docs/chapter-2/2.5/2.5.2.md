# 2.5.2 物品注册优化

### 模板类

首先我们需要一个基类`ItemBase`, 来当作注册物品时会用到的模板.

```java
public class ItemBase extends Item {
}
```

并将注册物品用到的代码写入构造函数.

```java
public class ItemBase extends Item {

    private String name;

    public ItemMod(String name){
        this.name = name;
        setRegistryName(name);
        setTranslationKey(Testmod.MOD_ID + "." + name);
    }
}
```

删除原有的`CreativeTabRegistry` , 将物品栏分类整合进此. (非强制,个人习惯)

```java
   public static final CreativeTabs TEST_MOD_TAB = new CreativeTabs(Testmod.MOD_ID) {

        @Override
        public ItemStack createIcon() {
            return new ItemStack(ItemRegistryHandler.INGOT_COPPER);
        }

        @Override
        public boolean hasSearchBar() {
            return true;
        }
    }.setBackgroundImageName("item_search.png");
```

## 模型注册简化
接下来要把模型注册的事件转移到代理中. 在接口类`IProxy`中添加空方法
```java
public void registerItemModel(Item item, int meta, String type) {  
}
```
在`ClientProxy`中实现该方法
```java
public void registerItemModel(Item item, int meta, String type) {  
    ModelLoader.setCustomModelResourceLocation(item, meta, new ModelResourceLocation(item.getRegistryName(), type));  
}
```


随后在模板类中调用.

```java
public class ItemBase extends Item {

    private String name;

    public ItemMod(String name){
        this.name = name;
        setRegistryName(name);
        setTranslationKey(Testmod.MOD_ID + "." + name);
        setCreativeTab(TEST_MOD_TAB);
    }

	@Override  
	public void registerModels() {  
	    Testmod.proxy.registerItemModel(this, 0 ,"inventory");  
	}

    public static final CreativeTabs TEST_MOD_TAB = new CreativeTabs(Testmod.MOD_ID) {

        @Override
        public ItemStack createIcon() {
            return new ItemStack(ItemRegistryHandler.INGOT_COPPER);
        }

        @Override
        public boolean hasSearchBar() {
            return true;
        }
    }.setBackgroundImageName("item_search.png");
}
```

## 物品列表类
整洁癖发作了, 所以单独再起一个类只负责实例化.

```java
public class ModItemList {  
    public static final List<Item> items = new ArrayList<Item>();  
  
    public static final Item INGOT_COPPER = new ItemIngotCopper();   
}
```

因为这里改用了数组, 所以模版类中的构造函数还要再加上`ModItemList.items.add(this);`
这样在实例化的时候便会自动加入到这个数组中.


然后只需要简单的修改下铜锭的继承,调用超类构造函数.

```java
public class ItemIngotCopper extends ItemMod {
    public ItemIngotCopper() {
        super("ingot_copper");
    }
}
```

### 修改注册类

`ModItems` 类的改动同样也不大. 因为实力部分移走了所以要删掉先前的. 

```java
@Mod.EventBusSubscriber
public class ModItems {

    @SubscribeEvent
    public static void onRegistry(RegistryEvent.Register<Item> event) {
        IForgeRegistry<Item> registry = event.getRegistry();

        registry.registerAll(ModItemList.items.toArray(new Item[0]));
    }
}
```
