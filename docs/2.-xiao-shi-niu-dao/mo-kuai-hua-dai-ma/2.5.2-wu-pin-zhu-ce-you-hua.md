# 2.5.2 物品注册优化

### 模板类

首先我们需要一个基类`ItemMod`, 来当作注册物品时会用到的模板.

```java
public class ItemMod extends Item {
}
```

并将注册物品用到的代码写入构造函数.

```java
public class ItemMod extends Item {

    private String name;

    public ItemMod(String name){
        this.name = name;
        setRegistryName(name);
        setTranslationKey(Testmod.MOD_ID + "." + name);
    }
}
```

删除原有的`CreativeTabRegistry` , 将物品栏分类整合进此. (非强制,个人习惯)

```java
   public static final CreativeTabs TEST_MOD_TAB = new CreativeTabs(Testmod.MOD_ID) {

        @Override
        public ItemStack createIcon() {
            return new ItemStack(ItemRegistryHandler.INGOT_COPPER);
        }

        @Override
        public boolean hasSearchBar() {
            return true;
        }
    }.setBackgroundImageName("item_search.png");
```

补上注册模型用的方法

```java
    @SideOnly(Side.CLIENT)
    public void registerItemModel() {
        ModelLoader.setCustomModelResourceLocation(this, 0, new ModelResourceLocation(getRegistryName(), "inventory"));
    }
```

至此模板类的创建就算是完成了.

```java
public class ItemMod extends Item {

    private String name;

    public ItemMod(String name){
        this.name = name;
        setRegistryName(name);
        setTranslationKey(Testmod.MOD_ID + "." + name);
        setCreativeTab(TEST_MOD_TAB);
    }

    @SideOnly(Side.CLIENT)
    public void registerItemModel() {
        ModelLoader.setCustomModelResourceLocation(this, 0, new ModelResourceLocation(getRegistryName(), "inventory"));
    }

    public static final CreativeTabs TEST_MOD_TAB = new CreativeTabs(Testmod.MOD_ID) {

        @Override
        public ItemStack createIcon() {
            return new ItemStack(ItemRegistryHandler.INGOT_COPPER);
        }

        @Override
        public boolean hasSearchBar() {
            return true;
        }
    }.setBackgroundImageName("item_search.png");
}
```

### 重新加入铜锭

这步我们只需要简单的修改下继承,调用超类构造函数.

```java
public class ItemIngotCopper extends ItemMod {
    public ItemIngotCopper() {
        super("ingot_copper");
    }
}
```

### 修改注册类

`ItemRegistryHandler` 类的改动同样也不大. 但是需要注意的是声明物品实例的时候需要从父类`ItemMod` 声明引用.

```java
@Mod.EventBusSubscriber
public class ItemRegistryHandler {

    public static final ItemMod INGOT_COPPER = new ItemIngotCopper();
//  public static final ItemIngotCopper INGOT_COPPER = new ItemIngotCopper();
//  注意引用,是ItemMod而不是ItemIngotCopper
//  否则无法调用registerItemModel()方法

    @SubscribeEvent
    public static void onRegistry(RegistryEvent.Register<Item> event) {
        IForgeRegistry<Item> registry = event.getRegistry();

        registry.registerAll(
                INGOT_COPPER
        );
    }

    @SubscribeEvent
    @SideOnly(Side.CLIENT)
    public static void onModelRegistry(ModelRegistryEvent event) {
        INGOT_COPPER.registerItemModel();
    }
}
```
